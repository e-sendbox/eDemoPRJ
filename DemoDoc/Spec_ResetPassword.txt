Содержание:

Введение
Обзор функциональности
Требования к системе
Архитектура и дизайн
Спецификация API (Backend)
Спецификация UI/UX (Frontend)
Тестирование и QA
Безопасность и развертывание

1. Введение
1.1 Цель документа
Настоящий документ содержит техническую спецификацию для реализации функциональности "Сброс пароля" в веб-приложении enterprise-уровня. Он адресован командам backend-разработки, frontend-разработки и QA для обеспечения согласованного понимания требований, архитектуры и этапов реализации. Функциональность сброса пароля обеспечивает восстановление доступа к аккаунтам в случае утери учетных данных, минимизируя риски безопасности и повышая удобство пользователей. Документ охватывает ключевые аспекты: от бизнес-требований до тестирования, с фокусом на compliance с GDPR, OWASP и WCAG 2.1. Ожидаемый объем работ — 150–250 человеко-часов, в зависимости от стека (Node.js/React или аналог).

Спецификация уточняет терминологию: вместо "токен" используется "идентификатор сброса" для обозначения временного, одноразового ключа верификации, интегрированного в авторизационную ссылку. Это предотвращает путаницу с механизмами сессионной аутентификации. Документ не включает SSO-интеграции, требующие отдельного описания.

1.2 Область применения
Функциональность применяется для всех типов пользователей: зарегистрированных, администраторов и гостей. Она интегрируется с JWT-аутентификацией и PostgreSQL-хранилищем. Основной механизм — email-восстановление. Система ориентирована на облачное развертывание (AWS), микросервисы и RESTful API. Область ограничена веб-интерфейсом.

1.3 Определения
Идентификатор сброса: Временный ключ (UUID или хэш), входящий в авторизационную ссылку для верификации права на смену пароля (TTL 15 мин).

Авторизационная ссылка: Защищенная URL-ссылка, отправляемая по email, содержащая идентификатор для доступа к форме сброса.


2. Обзор функциональности
2.1 Описание процесса
Процесс сброса пароля включает три этапа: запрос, верификация и обновление. Пользователь вводит email на странице логина. Система проверяет email (без раскрытия существования аккаунта), генерирует идентификатор сброса (UUID v4, хэшированный SHA-256) и сохраняет его в Redis с TTL 900 секунд. Авторизационная ссылка (с идентификатором в параметре) отправляется по email через SendGrid. Коммуникация — по HTTPS.

Верификация: Переход по ссылке извлекает идентификатор; frontend отображает форму пароля. Backend валидирует хэш, TTL и неиспользованность. Обновление: Новый пароль хэшируется (bcrypt, 12 раундов) и сохраняется в DB; идентификатор удаляется.

2.2 Потоки пользователя
Нормальный: Email → Авторизационная ссылка → Форма пароля → Обновление → Редирект на логин.

Альтернативный: Invalid email → Общее сообщение "Проверьте email, если аккаунт существует".

Исключительный: Истекший идентификатор → Ошибка с опцией повторного запроса (rate limit: 3/час).

Sequence diagram в Приложении A иллюстрирует взаимодействия: Client → API → Auth Service → Redis/DB → Notification.

2.3 Бизнес-требования
Многоязычность (EN, RU, DE) via i18n.

Rate limiting: 5 запросов/мин на IP.

Логирование: JSON-логи в ELK для аудита.

Уведомления: Email после сброса о потенциальной угрозе.

(Общий объем раздела: ~220 слов)

3. Требования к системе
3.1 Функциональные требования
FR-001: Запрос по email. Input: email; Output: Отправка ссылки или ошибка (400/429).

FR-002: Генерация идентификатора: Хранение в Redis (TTL 900 с), одноразовое использование.

FR-003: Валидация пароля: ≥8 символов (верхний/нижний регистр, цифра, спецсимвол); zxcvbn-score >3.

FR-004: Frontend: Responsive формы (Bootstrap/React Hook Form).

FR-005: Уведомления: HTML-шаблоны (MJML), SMS via Twilio.

3.2 Нефункциональные требования
Производительность: <200 мс (p95), 10k RPS.

Доступность: 99.9% uptime, WCAG 2.1 AA.

Безопасность: HTTPS, PCI DSS для паролей.

Масштабируемость: Docker/K8s, stateless services.

3.3 Аппаратные/программные требования
Backend: Node.js 18+/Python 3.11+, Express/FastAPI.

DB: PostgreSQL 14+, Redis 7+.

Frontend: React 18+, TypeScript.

Инфраструктура: AWS EC2 t3.medium, 4 GB RAM.

(Общий объем раздела: ~150 слов)

4. Архитектура и дизайн
4.1 Высокоуровневая архитектура
Микросервисная: Auth Service (логика), Notification Service (уведомления), Persistence (DB/Redis). API Gateway (Kong) — входная точка с rate limiting. Client (React SPA) → Gateway → Auth → DB/Redis.

4.2 Дизайн backend
Auth Service: Endpoints /forgot-password, /reset-password/{id}. DB: Таблица users (email unique, password_hash, reset_id, reset_expires). Индексы на email/id. Логи: Winston, метрики Prometheus. Интеграции: Nodemailer (email).

4.3 Дизайн frontend
Компоненты: ForgotForm, ResetForm (Yup-валидация). State: Redux для id/email. UI: Material-UI, ARIA для accessibility. Flows: Email → Ссылка → Пароль. Errors: Axios interceptors, toasts.

4.4 Диаграммы
Приложение B: UML классы, wireframes (Figma-style формы).


5. Спецификация API (Backend)
5.1 Эндпоинты
POST /api/v1/auth/forgot-password: Body {email}. Responses: 200 {"message": "Ссылка отправлена"}, 400 {"error": "Invalid email"}, 429 {"retryAfter": 60}.

POST /api/v1/auth/reset-password/{id}: Body {password, confirmPassword}. Responses: 200 {"message": "Сброс завершен"}, 400 {"error": "Weak password"}, 404 {"error": "Invalid id"}.

5.2 Модели данных
ResetRequest: {email: string (email format)}.

ResetPayload: {password: string (min 8, pattern), confirmPassword: string (match)}.

ErrorResponse: {error: string, code: number}.

5.3 Аутентификация и интеграции
Публичные endpoints. Валидация id: Middleware checks Redis hash/TTL. Rate: express-rate-limit (Redis). Email: SendGrid.


6. Спецификация UI/UX (Frontend)
6.1 Дизайн-система
Material-UI: Primary #1976d2, Error #d32f2f. Forms: Labels, placeholders, spinners. Responsive: Mobile-first.

6.2 User Flows
Login → "Забыли пароль?" → Email form → Success ("Проверьте email") → Ссылка → Password form → Update.

Errors: Real-time validation, snackbars. 2FA: Modal для SMS-кода.

6.3 Валидация и ошибки
Yup schemas; strength meter (zxcvbn). Offline: localStorage drafts. i18n: react-i18next (EN/RU/DE).

6.4 Accessibility
ARIA roles, keyboard nav, WCAG AA. Contrast >4.5:1.


7. Тестирование и QA
7.1 Unit Tests
Backend: Jest (80% coverage), mocks Redis/Email. Frontend: RTL, form tests.

7.2 Integration/E2E
Postman для API; Cypress для flows (email → reset). Load: Artillery (1000 users).

7.3 Security Testing
OWASP ZAP (XSS/SQLi); pen-test для id brute-force.

7.4 Checklist
Cross-browser (Chrome/Firefox); mobile (iOS/Android); localization; Lighthouse >90.


8. Безопасность и развертывание
8.1 Угрозы и меры
Spoofing: SPF/DKIM для email.

Brute-force: Rate limit, reCAPTCHA v3.

Хранение: Bcrypt, no plain-text. CSRF: Form tokens; CORS whitelist.

8.2 Стандарты
OWASP Top 10 (A02 Crypto, A07 Auth); GDPR (data min, consent).

8.3 Развертывание и мониторинг
CI/CD: GitHub Actions (lint/test/deploy). Envs: Dev/Staging/Prod (AWS EKS). Monitoring: New Relic (traces), ELK logs, Prometheus metrics (>99% success). Rollback: Blue-green.


Приложения
A. Диаграмма последовательности
[PlantUML описание]: User → Frontend → Gateway → Auth → DB (check email) → Redis (store id) → Email Service → User (ссылка). Return: Validate id → Update password.

B. Wireframes
Forgot: Email input + submit. Reset: Password fields + strength bar.

C. Примеры кода
Backend (Node.js):

javascript
app.post('/forgot-password', async (req, res) => {
  const { email } = req.body;
  if (!isEmail(email)) return res.status(400).json({ error: 'Invalid' });
  const user = await db.query('SELECT * FROM users WHERE email=?', [email]);
  if (user) {
    const id = randomUUID();
    const hash = sha256(id);
    await redis.setex(`reset:${email}`, 900, hash);
    await sendEmail(email, `Ссылка: ${BASE_URL}/reset/${id}`);
  }
  res.json({ message: 'Ссылка отправлена' });
});
Frontend (React):

tsx
const ForgotForm = () => {
  const { register, handleSubmit } = useForm();
  const onSubmit = async (data) => {
    await axios.post('/forgot-password', data);
    toast.success('Проверьте email');
  };
  return <form onSubmit={handleSubmit(onSubmit)}><input {...register('email')} /><button>Отправить</button></form>;
};
